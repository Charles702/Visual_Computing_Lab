import bpy
import bmesh
import numpy as np
# The map dipicts C1, C2, C3, C4, and u, v in this algorithm
# 
#              C2  --v --
#         _ _ _ _ _ _ _
#         |            |
#  |      |            |
#  U  C1  |            |  C3
#  |      |            |
#         |            |
#         |_ _ _ _  _ _|
#              C4  
#        
# explanation of ControlPoints.txt
# The begin word in every line indicate which curve the control points (X, Y,Z) is belong to 
# for example c1: 4, 6, 7 



def triangulate_object(obj):
    me = obj.data
    # Get a BMesh representation
    bm = bmesh.new()
    bm.from_mesh(me)

    bmesh.ops.triangulate(bm, faces=bm.faces[:])

    # Finish up, write the bmesh back to the mesh
    bm.to_mesh(me)
    bm.free()
    return me

#file_path="C:\\Users\\62501\\Desktop\\ControlPoints.txt"
#points = read3Dpoints(file_path)

# 2个ruled surface 加起来减 1个bilinear surface

#verts = [[1,1,1],[8,4,1],[5,2,1]]
#faces = [[0,1,2]]

def read3Dpoints(fileName):
    c1=[]
    c2=[]
    c3=[]
    c4=[]
    data = open(fileName,"r")
    for line in data:
        if line.startswith('#'):continue
        values=line.split()
        if not values:continue
        point=[]
        point.append(float(values[1]))
        point.append(float(values[2]))
        point.append(float(values[3]))
        if values[0] == "c1":
            c1.append(point)
        if values[0] == "c2":
            c2.append(point)
        if values[0] == "c3":
            c3.append(point)
        if values[0] == "c4":
            c4.append(point)           
    C1_cp = np.array(c1)
    C2_cp = np.array(c2)
    C3_cp = np.array(c3)
    C4_cp = np.array(c4)
    return C1_cp, C2_cp, C3_cp, C4_cp

def bezierCurv(points, timeSteps):
    newPoints = []
    n = len(points)
    for i in range(timeSteps):
        t = float(i)/(timeSteps -1)
        point = deCasteljauM(points,0, n-1, t)
        newPoints.append(point.tolist())
    return newPoints

# calculate Bezier curve using DeCasteljau Algorithm
def deCasteljauM(ControlP, i, j, t):
    if j == 0:
        return ControlP[i]
    return deCasteljauM(ControlP, i, j-1, t)*  (1-t) + deCasteljauM(ControlP, i+1, j-1, t) * t

# define how many points do you want to generated by Bezier Curve on  u and v direction
num_u = 10    # number of points generated by bezier curve in u direction (C1 , C3)
num_v = 10    # number of points generated by bezier curve in v direction (C2 , C4)

#read control points from file
file_path="C:\\Users\\62501\\Desktop\\ControlPoints.txt"
C1_cp,C2_cp,C3_cp,C4_cp = read3Dpoints(file_path)

#C1_cp = np.array([[1.0, 4.0, 3.0], [2.0, 3.0, 3.0], [4.0, 6.0, 3.0]])
#C3_cp = np.array([[2,6,0],[5,4,0],[7,1,0]])

#c2_cp = np.array([[1,4,3],[2,4,2],[2,6,0]])
#c4_cp = np.array([[4,6,3],[5,5,2],[7,1,0]])

# generate Bezier Curve
C1 = np.array(bezierCurv(C1_cp, num_u))
C3 = np.array(bezierCurv(C3_cp, num_u))

C2 = np.array(bezierCurv(C2_cp, num_v))
C4 = np.array(bezierCurv(C4_cp, num_v))

# counstruct ruled surface by C1 and C3
m1 = np.zeros((num_u, num_v, 3))
for n in range(num_u):
    for p in range(num_v):
        u = n/(num_u-1)
        v = p/(num_v-1)
        m1[n][p] = (1-v)*C1[n] + v * C3[n]

# Construct ruled surface by C2 and C4
m2 = np.zeros((num_u, num_v, 3))  
for n in range(num_u):
    for p in range(num_v):
        u = n/(num_u-1)
        m2[n][p] = (1-u)*C2[p] + u * C4[p]
        
# construct bilinear surface by C1[0] C[end]  C3[0] C3[end]
m3 = np.zeros((num_u,num_v,3))
for n in range(num_u):
    for p in range(num_v):
        u = n/(num_u-1)
        v = p/(num_v-1)
        m3[n][p] = (1-v)*(1-u)*C1[0] + (1-v)*u*C1[num_u-1] + v*(1-u)*C3[0]+v*u*C3[num_u-1]

# construct coons patch vertices: ruled surface ( C1,C3) + ruled surface(C2,C4) - bilinear surface
m = m1 +m2 -m3

#indice lookup table
loopupIndex = np.zeros((num_u,num_v))
for n in range(num_u):
    for p in range(num_v):
        loopupIndex[n][p]= n*num_v + p

# construct vertices list for mesh
vertices = []
for n in range(num_u):
    for p in range(num_v):
        ## push vertices into list
        vertices.append(m[n][p].tolist())

# create faces
faces = []
for n in range(num_u-1):
    for p in range(num_v-1):
        face = []
        face.append(loopupIndex[n][p])
        face.append(loopupIndex[n][p+1])
        face.append(loopupIndex[n+1][p+1])
        face.append(loopupIndex[n+1][p])
        faces.append(face)


#  draw mesh for Coons patch
origin = [0,0,0]
name = " Coons Patch -"
me = bpy.data.meshes.new(name+'Mesh')
ob = bpy.data.objects.new(name, me)
ob.location = origin
ob.show_name = True
 
scn = bpy.context.scene
scn.collection.objects.link(ob)

bpy.context.view_layer.objects.active=ob
ob.select_set(True)

 
# Create mesh from given verts, faces.
me.from_pydata(vertices, [], faces)
#Update mesh with new data
#me=triangulate_object(ob)
me.update()  



